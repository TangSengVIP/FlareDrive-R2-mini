name: Sync GitHub Release Assets to Cloudflare R2

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to sync (leave empty for latest)"
        required: false
        default: ""
  schedule:
    - cron: "0 3 * * *"

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      R2_ENDPOINT: https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
      R2_BUCKET: ${{ secrets.R2_BUCKET_NAME }}
      SOURCE_REPO: ${{ secrets.GH_SOURCE_REPO }}
      SOURCE_REPOS: ${{ secrets.GH_SOURCE_REPOS }}
    steps:
      - name: Checkout (for reference)
        uses: actions/checkout@v4

      - name: Preflight check (validate required secrets)
        env:
          GH_SOURCE_TOKEN: ${{ secrets.GH_SOURCE_TOKEN }}
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          SOURCE_REPO: ${{ secrets.GH_SOURCE_REPO }}
          SOURCE_REPOS: ${{ secrets.GH_SOURCE_REPOS }}
        run: |
          set -e
          missing=0
          for var in GH_SOURCE_TOKEN R2_ACCOUNT_ID R2_BUCKET_NAME R2_ACCESS_KEY_ID R2_SECRET_ACCESS_KEY; do
            if [ -z "${!var}" ]; then echo "[ERROR] Missing secret: $var"; missing=1; fi
          done
          if [ -z "$SOURCE_REPO" ] && [ -z "$SOURCE_REPOS" ]; then
            echo "[ERROR] Provide at least one of: GH_SOURCE_REPO or GH_SOURCE_REPOS"; missing=1
          fi
          if [ $missing -ne 0 ]; then
            echo "Secrets validation failed — please add missing secrets in Settings → Secrets and variables → Actions";
            exit 1
          fi

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          pipx install awscli

      - name: Configure AWS for R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        run: |
          aws --version
          aws configure set aws_access_key_id "$AWS_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$AWS_SECRET_ACCESS_KEY"
          aws configure set default.region "auto"

      - name: Resolve & download assets for single repo (fallback)
        env:
          GH_TOKEN: ${{ secrets.GH_SOURCE_TOKEN }}
        run: |
          # If multiple repos are provided, skip this step (handled in next step)
          if [ -n "$SOURCE_REPOS" ]; then
            echo "Multiple repos configured; skipping single-repo fallback"
            exit 0
          fi
          if [ -z "$SOURCE_REPO" ]; then
            echo "No SOURCE_REPO provided and no SOURCE_REPOS list; nothing to sync"
            exit 0
          fi
          TAG_INPUT='${{ github.event.inputs.tag }}'
          if [ -z "$TAG_INPUT" ]; then
            curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/$SOURCE_REPO/releases/latest" > release.json
          else
            curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/$SOURCE_REPO/releases/tags/$TAG_INPUT" > release.json
          fi
          mkdir -p downloads
          ASSET_COUNT=$(jq '.assets | length' release.json)
          echo "[$SOURCE_REPO] Found $ASSET_COUNT assets"
          for row in $(jq -r '.assets[] | @base64' release.json); do
            _jq() { echo ${row} | base64 -d | jq -r ${1}; }
            NAME=$(_jq '.name')
            URL=$(_jq '.browser_download_url')
            LOWER=$(echo "$NAME" | tr '[:upper:]' '[:lower:]')
            TARGET_PREFIX=""
            # Platform filter
            if echo "$LOWER" | grep -E '\.(exe|msi)$' >/dev/null; then
              TARGET_PREFIX="windows"
            elif echo "$LOWER" | grep -E '\.(dmg|pkg)$' >/dev/null; then
              if echo "$LOWER" | grep -E '(arm64|aarch64|apple|silicon|m1|m2|m3)' >/dev/null; then
                TARGET_PREFIX="macos/apple"
              else
                TARGET_PREFIX="macos/intel"
              fi
            elif echo "$LOWER" | grep -E '\.(apk|aab)$' >/dev/null; then
              TARGET_PREFIX="android"
            else
              echo "Skip non-target asset: $NAME"
              continue
            fi
            # Repo-specific whitelists
            ACCEPT=1
            REPO_NAME="$SOURCE_REPO"
            if echo "$REPO_NAME" | grep -qi '^chen08209/flclash$'; then
              if [ "$TARGET_PREFIX" = "windows" ]; then
                echo "$LOWER" | grep -Eq '^flclash-[0-9]+\.[0-9]+(\.[0-9]+)?-windows-amd64-setup\.exe$' || ACCEPT=0
              elif [ "$TARGET_PREFIX" = "android" ]; then
                echo "$LOWER" | grep -Eq 'android-arm64-v8a\.apk$' || ACCEPT=0
              fi
            elif echo "$REPO_NAME" | grep -qi '^zzzgydi/clash-verge-rev$' || echo "$REPO_NAME" | grep -qi '^clash-verge-rev/clash-verge-rev$'; then
              if [ "$TARGET_PREFIX" = "windows" ]; then
                echo "$LOWER" | grep -Eq '^clash\.verge_[0-9]+\.[0-9]+\.[0-9]+_x64-setup\.exe$' || ACCEPT=0
              elif [ "$TARGET_PREFIX" = "macos/apple" ] || [ "$TARGET_PREFIX" = "macos/intel" ]; then
                echo "$LOWER" | grep -Eq '\.(dmg|pkg)$' || ACCEPT=0
              else
                ACCEPT=0
              fi
            elif echo "$REPO_NAME" | grep -qi '^metacubex/clashmetaforandroid$'; then
              if [ "$TARGET_PREFIX" = "android" ]; then
                echo "$LOWER" | grep -Eq 'meta-arm64-v8a-release\.apk$' || ACCEPT=0
              else
                ACCEPT=0
              fi
            fi
            if [ $ACCEPT -ne 1 ]; then
              echo "Skip by whitelist: $NAME"
              continue
            fi
            echo "Downloading $NAME -> $TARGET_PREFIX"
            curl -L -H "Authorization: token $GH_TOKEN" -H "Accept: application/octet-stream" \
              "$URL" -o "downloads/$NAME"
            aws s3 cp "downloads/$NAME" "s3://$R2_BUCKET/$TARGET_PREFIX/$NAME" --endpoint-url "$R2_ENDPOINT"
          done
          aws s3 ls s3://$R2_BUCKET/ --recursive --endpoint-url "$R2_ENDPOINT" || true

      - name: Resolve & download assets for multiple repos
        if: env.SOURCE_REPOS != ''
        env:
          GH_TOKEN: ${{ secrets.GH_SOURCE_TOKEN }}
        run: |
          # Expected format in GH_SOURCE_REPOS: "owner1/repo1|prefix1;owner2/repo2|prefix2|v1.2.3"
          IFS=';' read -r -a ITEMS <<< "$SOURCE_REPOS"
          for ITEM in "${ITEMS[@]}"; do
            REPO=$(echo "$ITEM" | awk -F '|' '{print $1}')
            PREFIX=$(echo "$ITEM" | awk -F '|' '{print $2}')
            TAG_SPEC=$(echo "$ITEM" | awk -F '|' '{print $3}')
            TAG_INPUT='${{ github.event.inputs.tag }}'
            TAG=${TAG_SPEC:-$TAG_INPUT}
            echo "Processing repo=$REPO prefix=${PREFIX:-(root)} tag=${TAG:-latest}"
            if [ -z "$TAG" ]; then
              curl -s -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/$REPO/releases/latest" > release.json
            else
              curl -s -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/$REPO/releases/tags/$TAG" > release.json
            fi
            mkdir -p downloads
            ASSET_COUNT=$(jq '.assets | length' release.json)
            echo "[$REPO] Found $ASSET_COUNT assets"
            for row in $(jq -r '.assets[] | @base64' release.json); do
              _jq() { echo ${row} | base64 -d | jq -r ${1}; }
              NAME=$(_jq '.name')
              URL=$(_jq '.browser_download_url')
              LOWER=$(echo "$NAME" | tr '[:upper:]' '[:lower:]')
              PLATFORM_PREFIX=""
              if echo "$LOWER" | grep -E '\.(exe|msi)$' >/dev/null; then
                PLATFORM_PREFIX="windows"
              elif echo "$LOWER" | grep -E '\.(dmg|pkg)$' >/dev/null; then
                if echo "$LOWER" | grep -E '(arm64|aarch64|apple|silicon|m1|m2|m3)' >/dev/null; then
                  PLATFORM_PREFIX="macos/apple"
                else
                  PLATFORM_PREFIX="macos/intel"
                fi
              elif echo "$LOWER" | grep -E '\.(apk|aab)$' >/dev/null; then
                PLATFORM_PREFIX="android"
              else
                echo "Skip non-target asset: $NAME"
                continue
              fi
              # Repo-specific whitelists
              ACCEPT=1
              if echo "$REPO" | grep -qi '^chen08209/flclash$'; then
                if [ "$PLATFORM_PREFIX" = "windows" ]; then
                  echo "$LOWER" | grep -Eq '^flclash-[0-9]+\.[0-9]+(\.[0-9]+)?-windows-amd64-setup\.exe$' || ACCEPT=0
                elif [ "$PLATFORM_PREFIX" = "android" ]; then
                  echo "$LOWER" | grep -Eq 'android-arm64-v8a\.apk$' || ACCEPT=0
                fi
              elif echo "$REPO" | grep -qi '^zzzgydi/clash-verge-rev$' || echo "$REPO" | grep -qi '^clash-verge-rev/clash-verge-rev$'; then
                if [ "$PLATFORM_PREFIX" = "windows" ]; then
                  echo "$LOWER" | grep -Eq '^clash\.verge_[0-9]+\.[0-9]+\.[0-9]+_x64-setup\.exe$' || ACCEPT=0
                elif [ "$PLATFORM_PREFIX" = "macos/apple" ] || [ "$PLATFORM_PREFIX" = "macos/intel" ]; then
                  echo "$LOWER" | grep -Eq '\.(dmg|pkg)$' || ACCEPT=0
                else
                  ACCEPT=0
                fi
              elif echo "$REPO" | grep -qi '^metacubex/clashmetaforandroid$'; then
                if [ "$PLATFORM_PREFIX" = "android" ]; then
                  echo "$LOWER" | grep -Eq 'meta-arm64-v8a-release\.apk$' || ACCEPT=0
                else
                  ACCEPT=0
                fi
              fi
              if [ $ACCEPT -ne 1 ]; then
                echo "Skip by whitelist: $NAME"
                continue
              fi
              DEST_PREFIX="$PLATFORM_PREFIX"
              if [ -n "$PREFIX" ]; then
                DEST_PREFIX="$PREFIX/$PLATFORM_PREFIX"
              fi
              echo "Downloading $NAME -> $DEST_PREFIX"
              curl -L -H "Authorization: token $GH_TOKEN" -H "Accept: application/octet-stream" \
                "$URL" -o "downloads/$NAME"
              aws s3 cp "downloads/$NAME" "s3://$R2_BUCKET/$DEST_PREFIX/$NAME" --endpoint-url "$R2_ENDPOINT"
            done
            rm -rf downloads
          done
          aws s3 ls s3://$R2_BUCKET/ --recursive --endpoint-url "$R2_ENDPOINT" || true
